// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * default-bindings-module: "crate::bindings::scanner_world"
#[allow(dead_code, clippy::all)]
pub mod exports {
  pub mod ritalin {
    pub mod scanner {

      #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
      pub mod types {
        #[used]
        #[doc(hidden)]
        static __FORCE_SECTION_REF: fn() =
        super::super::super::super::__link_custom_section_describing_imports;
        
        use super::super::super::super::_rt;
        #[derive(Clone)]
        pub struct SyntaxKind {
          pub id: u32,
          pub text: _rt::String,
          pub is_keyword: bool,
          pub is_terminal: bool,
        }
        impl ::core::fmt::Debug for SyntaxKind {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("SyntaxKind").field("id", &self.id).field("text", &self.text).field("is-keyword", &self.is_keyword).field("is-terminal", &self.is_terminal).finish()
          }
        }
        #[derive(Clone)]
        pub struct TokenItem {
          pub kind: SyntaxKind,
          pub offset: u32,
          pub len: u32,
          pub value: Option<_rt::String>,
        }
        impl ::core::fmt::Debug for TokenItem {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("TokenItem").field("kind", &self.kind).field("offset", &self.offset).field("len", &self.len).field("value", &self.value).finish()
          }
        }
        #[derive(Clone)]
        pub struct Token {
          pub leading: Option<_rt::Vec::<TokenItem>>,
          pub main: TokenItem,
          pub trailing: Option<_rt::Vec::<TokenItem>>,
        }
        impl ::core::fmt::Debug for Token {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("Token").field("leading", &self.leading).field("main", &self.main).field("trailing", &self.trailing).finish()
          }
        }
        #[derive(Clone)]
        pub struct ScannerScope {
          pub next_index: u32,
          pub lookahead: Option<Token>,
        }
        impl ::core::fmt::Debug for ScannerScope {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("ScannerScope").field("next-index", &self.next_index).field("lookahead", &self.lookahead).finish()
          }
        }
        #[doc(hidden)]

        macro_rules! __export_ritalin_scanner_types_0_0_1_cabi{
          ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

          };);
        }
        #[doc(hidden)]
        pub(crate) use __export_ritalin_scanner_types_0_0_1_cabi;

      }


      #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
      pub mod scanners {
        #[used]
        #[doc(hidden)]
        static __FORCE_SECTION_REF: fn() =
        super::super::super::super::__link_custom_section_describing_imports;
        
        use super::super::super::super::_rt;
        pub type Token = super::super::super::super::exports::ritalin::scanner::types::Token;
        pub type ScannerScope = super::super::super::super::exports::ritalin::scanner::types::ScannerScope;

        #[derive(Debug)]
        #[repr(transparent)]
        pub struct Scanner{
          handle: _rt::Resource<Scanner>,
        }

        type _ScannerRep<T> = Option<T>;

        impl Scanner{
          /// Creates a new resource from the specified representation.
          ///
          /// This function will create a new resource handle by moving `val` onto
          /// the heap and then passing that heap pointer to the component model to
          /// create a handle. The owned handle is then returned as `Scanner`.
          pub fn new<T: GuestScanner>(val: T) -> Self {
            Self::type_guard::<T>();
            let val: _ScannerRep<T> = Some(val);
            let ptr: *mut _ScannerRep<T> =
            _rt::Box::into_raw(_rt::Box::new(val));
            unsafe {
              Self::from_handle(T::_resource_new(ptr.cast()))
            }
          }

          /// Gets access to the underlying `T` which represents this resource.
          pub fn get<T: GuestScanner>(&self) -> &T {
            let ptr = unsafe { &*self.as_ptr::<T>() };
            ptr.as_ref().unwrap()
          }

          /// Gets mutable access to the underlying `T` which represents this
          /// resource.
          pub fn get_mut<T: GuestScanner>(&mut self) -> &mut T {
            let ptr = unsafe { &mut *self.as_ptr::<T>() };
            ptr.as_mut().unwrap()
          }

          /// Consumes this resource and returns the underlying `T`.
          pub fn into_inner<T: GuestScanner>(self) -> T {
            let ptr = unsafe { &mut *self.as_ptr::<T>() };
            ptr.take().unwrap()
          }

          #[doc(hidden)]
          pub unsafe fn from_handle(handle: u32) -> Self {
            Self {
              handle: unsafe { _rt::Resource::from_handle(handle) },
            }
          }

          #[doc(hidden)]
          pub fn take_handle(&self) -> u32 {
            _rt::Resource::take_handle(&self.handle)
          }

          #[doc(hidden)]
          pub fn handle(&self) -> u32 {
            _rt::Resource::handle(&self.handle)
          }

          // It's theoretically possible to implement the `GuestScanner` trait twice
          // so guard against using it with two different types here.
          #[doc(hidden)]
          fn type_guard<T: 'static>() {
            use core::any::TypeId;
            static mut LAST_TYPE: Option<TypeId> = None;
            unsafe {
              assert!(!cfg!(target_feature = "atomics"));
              let id = TypeId::of::<T>();
              match LAST_TYPE {
                Some(ty) => assert!(ty == id, "cannot use two types with this resource type"),
                None => LAST_TYPE = Some(id),
              }
            }
          }

          #[doc(hidden)]
          pub unsafe fn dtor<T: 'static>(handle: *mut u8) {
            Self::type_guard::<T>();
            let _ = unsafe { _rt::Box::from_raw(handle as *mut _ScannerRep<T>) };
          }

          fn as_ptr<T: GuestScanner>(&self) -> *mut _ScannerRep<T> {
            Scanner::type_guard::<T>();
            T::_resource_rep(self.handle()).cast()
          }
        }

        /// A borrowed version of [`Scanner`] which represents a borrowed value
        /// with the lifetime `'a`.
        #[derive(Debug)]
        #[repr(transparent)]
        pub struct ScannerBorrow<'a> {
          rep: *mut u8,
          _marker: core::marker::PhantomData<&'a Scanner>,
        }

        impl<'a> ScannerBorrow<'a>{
          #[doc(hidden)]
          pub unsafe fn lift(rep: usize) -> Self {
            Self {
              rep: rep as *mut u8,
              _marker: core::marker::PhantomData,
            }
          }

          /// Gets access to the underlying `T` in this resource.
          pub fn get<T: GuestScanner>(&self) -> &T {
            let ptr = unsafe { &mut *self.as_ptr::<T>() };
            ptr.as_ref().unwrap()
          }

          // NB: mutable access is not allowed due to the component model allowing
          // multiple borrows of the same resource.

          fn as_ptr<T: 'static>(&self) -> *mut _ScannerRep<T> {
            Scanner::type_guard::<T>();
            self.rep.cast()
          }
        }
        

        unsafe impl _rt::WasmResource for Scanner{
          #[inline]
          unsafe fn drop(_handle: u32) {
            #[cfg(not(target_arch = "wasm32"))]
            unreachable!();

            #[cfg(target_arch = "wasm32")]
            {
              #[link(wasm_import_module = "[export]ritalin:scanner/scanners@0.0.1")]
              unsafe extern "C" {
                #[link_name = "[resource-drop]scanner"]
                fn drop(_: u32);
              }

              unsafe { drop(_handle) };
            }
          }
        }
        
        #[doc(hidden)]
        #[allow(non_snake_case)]
        pub unsafe fn _export_static_scanner_create_cabi<T: GuestScanner>(arg0: *mut u8,arg1: usize,arg2: i32,) -> i32 {#[cfg(target_arch="wasm32")]
        _rt::run_ctors_once();let len0 = arg1;
        let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
        let result1 = T::create(_rt::string_lift(bytes0), arg2 as u32);
        (result1).take_handle() as i32
      }
      #[doc(hidden)]
      #[allow(non_snake_case)]
      pub unsafe fn _export_method_scanner_lookahead_cabi<T: GuestScanner>(arg0: *mut u8,) -> *mut u8 {#[cfg(target_arch="wasm32")]
      _rt::run_ctors_once();let result0 = T::lookahead(unsafe { ScannerBorrow::lift(arg0 as u32 as usize) }.get());
      let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
      match result0 {
        Some(e) => {
          *ptr1.add(0).cast::<u8>() = (1i32) as u8;
          let super::super::super::super::exports::ritalin::scanner::types::Token{ leading:leading2, main:main2, trailing:trailing2, } = e;
          match leading2 {
            Some(e) => {
              *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
              let vec7 = e;
              let len7 = vec7.len();
              let layout7 = _rt::alloc::Layout::from_size_align_unchecked(vec7.len() * (8+7*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
              let result7 = if layout7.size() != 0 {
                let ptr = _rt::alloc::alloc(layout7).cast::<u8>();
                if ptr.is_null()
                {
                  _rt::alloc::handle_alloc_error(layout7);
                }
                ptr
              }else {
                ::core::ptr::null_mut()
              };
              for (i, e) in vec7.into_iter().enumerate() {
                let base = result7.add(i * (8+7*::core::mem::size_of::<*const u8>()));
                {
                  let super::super::super::super::exports::ritalin::scanner::types::TokenItem{ kind:kind3, offset:offset3, len:len3, value:value3, } = e;
                  let super::super::super::super::exports::ritalin::scanner::types::SyntaxKind{ id:id4, text:text4, is_keyword:is_keyword4, is_terminal:is_terminal4, } = kind3;
                  *base.add(0).cast::<i32>() = _rt::as_i32(id4);
                  let vec5 = (text4.into_bytes()).into_boxed_slice();
                  let ptr5 = vec5.as_ptr().cast::<u8>();
                  let len5 = vec5.len();
                  ::core::mem::forget(vec5);
                  *base.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
                  *base.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr5.cast_mut();
                  *base.add(3*::core::mem::size_of::<*const u8>()).cast::<u8>() = (match is_keyword4 { true => 1, false => 0 }) as u8;
                  *base.add(1+3*::core::mem::size_of::<*const u8>()).cast::<u8>() = (match is_terminal4 { true => 1, false => 0 }) as u8;
                  *base.add(4*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(offset3);
                  *base.add(4+4*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(len3);
                  match value3 {
                    Some(e) => {
                      *base.add(8+4*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                      let vec6 = (e.into_bytes()).into_boxed_slice();
                      let ptr6 = vec6.as_ptr().cast::<u8>();
                      let len6 = vec6.len();
                      ::core::mem::forget(vec6);
                      *base.add(8+6*::core::mem::size_of::<*const u8>()).cast::<usize>() = len6;
                      *base.add(8+5*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr6.cast_mut();
                    },
                    None => {
                      {
                        *base.add(8+4*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };}
                }
                *ptr1.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
                *ptr1.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result7;
              },
              None => {
                {
                  *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                }
              },
            };let super::super::super::super::exports::ritalin::scanner::types::TokenItem{ kind:kind8, offset:offset8, len:len8, value:value8, } = main2;
            let super::super::super::super::exports::ritalin::scanner::types::SyntaxKind{ id:id9, text:text9, is_keyword:is_keyword9, is_terminal:is_terminal9, } = kind8;
            *ptr1.add(4*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(id9);
            let vec10 = (text9.into_bytes()).into_boxed_slice();
            let ptr10 = vec10.as_ptr().cast::<u8>();
            let len10 = vec10.len();
            ::core::mem::forget(vec10);
            *ptr1.add(6*::core::mem::size_of::<*const u8>()).cast::<usize>() = len10;
            *ptr1.add(5*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr10.cast_mut();
            *ptr1.add(7*::core::mem::size_of::<*const u8>()).cast::<u8>() = (match is_keyword9 { true => 1, false => 0 }) as u8;
            *ptr1.add(1+7*::core::mem::size_of::<*const u8>()).cast::<u8>() = (match is_terminal9 { true => 1, false => 0 }) as u8;
            *ptr1.add(8*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(offset8);
            *ptr1.add(4+8*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(len8);
            match value8 {
              Some(e) => {
                *ptr1.add(8+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                let vec11 = (e.into_bytes()).into_boxed_slice();
                let ptr11 = vec11.as_ptr().cast::<u8>();
                let len11 = vec11.len();
                ::core::mem::forget(vec11);
                *ptr1.add(8+10*::core::mem::size_of::<*const u8>()).cast::<usize>() = len11;
                *ptr1.add(8+9*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr11.cast_mut();
              },
              None => {
                {
                  *ptr1.add(8+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                }
              },
            };match trailing2 {
              Some(e) => {
                *ptr1.add(8+11*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                let vec16 = e;
                let len16 = vec16.len();
                let layout16 = _rt::alloc::Layout::from_size_align_unchecked(vec16.len() * (8+7*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
                let result16 = if layout16.size() != 0 {
                  let ptr = _rt::alloc::alloc(layout16).cast::<u8>();
                  if ptr.is_null()
                  {
                    _rt::alloc::handle_alloc_error(layout16);
                  }
                  ptr
                }else {
                  ::core::ptr::null_mut()
                };
                for (i, e) in vec16.into_iter().enumerate() {
                  let base = result16.add(i * (8+7*::core::mem::size_of::<*const u8>()));
                  {
                    let super::super::super::super::exports::ritalin::scanner::types::TokenItem{ kind:kind12, offset:offset12, len:len12, value:value12, } = e;
                    let super::super::super::super::exports::ritalin::scanner::types::SyntaxKind{ id:id13, text:text13, is_keyword:is_keyword13, is_terminal:is_terminal13, } = kind12;
                    *base.add(0).cast::<i32>() = _rt::as_i32(id13);
                    let vec14 = (text13.into_bytes()).into_boxed_slice();
                    let ptr14 = vec14.as_ptr().cast::<u8>();
                    let len14 = vec14.len();
                    ::core::mem::forget(vec14);
                    *base.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len14;
                    *base.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr14.cast_mut();
                    *base.add(3*::core::mem::size_of::<*const u8>()).cast::<u8>() = (match is_keyword13 { true => 1, false => 0 }) as u8;
                    *base.add(1+3*::core::mem::size_of::<*const u8>()).cast::<u8>() = (match is_terminal13 { true => 1, false => 0 }) as u8;
                    *base.add(4*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(offset12);
                    *base.add(4+4*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(len12);
                    match value12 {
                      Some(e) => {
                        *base.add(8+4*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                        let vec15 = (e.into_bytes()).into_boxed_slice();
                        let ptr15 = vec15.as_ptr().cast::<u8>();
                        let len15 = vec15.len();
                        ::core::mem::forget(vec15);
                        *base.add(8+6*::core::mem::size_of::<*const u8>()).cast::<usize>() = len15;
                        *base.add(8+5*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr15.cast_mut();
                      },
                      None => {
                        {
                          *base.add(8+4*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                        }
                      },
                    };}
                  }
                  *ptr1.add(8+13*::core::mem::size_of::<*const u8>()).cast::<usize>() = len16;
                  *ptr1.add(8+12*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result16;
                },
                None => {
                  {
                    *ptr1.add(8+11*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };},
              None => {
                {
                  *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                }
              },
            };ptr1
          }
          #[doc(hidden)]
          #[allow(non_snake_case)]
          pub unsafe fn __post_return_method_scanner_lookahead<T: GuestScanner>(arg0: *mut u8,) {
            let l0 = i32::from(*arg0.add(0).cast::<u8>());
            match l0 {
              0 => (),
              _ => {
                let l1 = i32::from(*arg0.add(::core::mem::size_of::<*const u8>()).cast::<u8>());
                match l1 {
                  0 => (),
                  _ => {
                    let l2 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l3 = *arg0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let base9 = l2;
                    let len9 = l3;
                    for i in 0..len9 {
                      let base = base9.add(i * (8+7*::core::mem::size_of::<*const u8>()));
                      {
                        let l4 = *base.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l5 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        _rt::cabi_dealloc(l4, l5, 1);
                        let l6 = i32::from(*base.add(8+4*::core::mem::size_of::<*const u8>()).cast::<u8>());
                        match l6 {
                          0 => (),
                          _ => {
                            let l7 = *base.add(8+5*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                            let l8 = *base.add(8+6*::core::mem::size_of::<*const u8>()).cast::<usize>();
                            _rt::cabi_dealloc(l7, l8, 1);
                          },
                        }
                      }
                    }
                    _rt::cabi_dealloc(base9, len9 * (8+7*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
                  },
                }
                let l10 = *arg0.add(5*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l11 = *arg0.add(6*::core::mem::size_of::<*const u8>()).cast::<usize>();
                _rt::cabi_dealloc(l10, l11, 1);
                let l12 = i32::from(*arg0.add(8+8*::core::mem::size_of::<*const u8>()).cast::<u8>());
                match l12 {
                  0 => (),
                  _ => {
                    let l13 = *arg0.add(8+9*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l14 = *arg0.add(8+10*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l13, l14, 1);
                  },
                }
                let l15 = i32::from(*arg0.add(8+11*::core::mem::size_of::<*const u8>()).cast::<u8>());
                match l15 {
                  0 => (),
                  _ => {
                    let l16 = *arg0.add(8+12*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l17 = *arg0.add(8+13*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let base23 = l16;
                    let len23 = l17;
                    for i in 0..len23 {
                      let base = base23.add(i * (8+7*::core::mem::size_of::<*const u8>()));
                      {
                        let l18 = *base.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l19 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        _rt::cabi_dealloc(l18, l19, 1);
                        let l20 = i32::from(*base.add(8+4*::core::mem::size_of::<*const u8>()).cast::<u8>());
                        match l20 {
                          0 => (),
                          _ => {
                            let l21 = *base.add(8+5*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                            let l22 = *base.add(8+6*::core::mem::size_of::<*const u8>()).cast::<usize>();
                            _rt::cabi_dealloc(l21, l22, 1);
                          },
                        }
                      }
                    }
                    _rt::cabi_dealloc(base23, len23 * (8+7*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
                  },
                }
              },
            }
          }
          #[doc(hidden)]
          #[allow(non_snake_case)]
          pub unsafe fn _export_method_scanner_shift_cabi<T: GuestScanner>(arg0: *mut u8,) -> *mut u8 {#[cfg(target_arch="wasm32")]
          _rt::run_ctors_once();let result0 = T::shift(unsafe { ScannerBorrow::lift(arg0 as u32 as usize) }.get());
          let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
          match result0 {
            Some(e) => {
              *ptr1.add(0).cast::<u8>() = (1i32) as u8;
              let super::super::super::super::exports::ritalin::scanner::types::Token{ leading:leading2, main:main2, trailing:trailing2, } = e;
              match leading2 {
                Some(e) => {
                  *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec7 = e;
                  let len7 = vec7.len();
                  let layout7 = _rt::alloc::Layout::from_size_align_unchecked(vec7.len() * (8+7*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
                  let result7 = if layout7.size() != 0 {
                    let ptr = _rt::alloc::alloc(layout7).cast::<u8>();
                    if ptr.is_null()
                    {
                      _rt::alloc::handle_alloc_error(layout7);
                    }
                    ptr
                  }else {
                    ::core::ptr::null_mut()
                  };
                  for (i, e) in vec7.into_iter().enumerate() {
                    let base = result7.add(i * (8+7*::core::mem::size_of::<*const u8>()));
                    {
                      let super::super::super::super::exports::ritalin::scanner::types::TokenItem{ kind:kind3, offset:offset3, len:len3, value:value3, } = e;
                      let super::super::super::super::exports::ritalin::scanner::types::SyntaxKind{ id:id4, text:text4, is_keyword:is_keyword4, is_terminal:is_terminal4, } = kind3;
                      *base.add(0).cast::<i32>() = _rt::as_i32(id4);
                      let vec5 = (text4.into_bytes()).into_boxed_slice();
                      let ptr5 = vec5.as_ptr().cast::<u8>();
                      let len5 = vec5.len();
                      ::core::mem::forget(vec5);
                      *base.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
                      *base.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr5.cast_mut();
                      *base.add(3*::core::mem::size_of::<*const u8>()).cast::<u8>() = (match is_keyword4 { true => 1, false => 0 }) as u8;
                      *base.add(1+3*::core::mem::size_of::<*const u8>()).cast::<u8>() = (match is_terminal4 { true => 1, false => 0 }) as u8;
                      *base.add(4*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(offset3);
                      *base.add(4+4*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(len3);
                      match value3 {
                        Some(e) => {
                          *base.add(8+4*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                          let vec6 = (e.into_bytes()).into_boxed_slice();
                          let ptr6 = vec6.as_ptr().cast::<u8>();
                          let len6 = vec6.len();
                          ::core::mem::forget(vec6);
                          *base.add(8+6*::core::mem::size_of::<*const u8>()).cast::<usize>() = len6;
                          *base.add(8+5*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr6.cast_mut();
                        },
                        None => {
                          {
                            *base.add(8+4*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };}
                    }
                    *ptr1.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
                    *ptr1.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result7;
                  },
                  None => {
                    {
                      *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };let super::super::super::super::exports::ritalin::scanner::types::TokenItem{ kind:kind8, offset:offset8, len:len8, value:value8, } = main2;
                let super::super::super::super::exports::ritalin::scanner::types::SyntaxKind{ id:id9, text:text9, is_keyword:is_keyword9, is_terminal:is_terminal9, } = kind8;
                *ptr1.add(4*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(id9);
                let vec10 = (text9.into_bytes()).into_boxed_slice();
                let ptr10 = vec10.as_ptr().cast::<u8>();
                let len10 = vec10.len();
                ::core::mem::forget(vec10);
                *ptr1.add(6*::core::mem::size_of::<*const u8>()).cast::<usize>() = len10;
                *ptr1.add(5*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr10.cast_mut();
                *ptr1.add(7*::core::mem::size_of::<*const u8>()).cast::<u8>() = (match is_keyword9 { true => 1, false => 0 }) as u8;
                *ptr1.add(1+7*::core::mem::size_of::<*const u8>()).cast::<u8>() = (match is_terminal9 { true => 1, false => 0 }) as u8;
                *ptr1.add(8*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(offset8);
                *ptr1.add(4+8*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(len8);
                match value8 {
                  Some(e) => {
                    *ptr1.add(8+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    let vec11 = (e.into_bytes()).into_boxed_slice();
                    let ptr11 = vec11.as_ptr().cast::<u8>();
                    let len11 = vec11.len();
                    ::core::mem::forget(vec11);
                    *ptr1.add(8+10*::core::mem::size_of::<*const u8>()).cast::<usize>() = len11;
                    *ptr1.add(8+9*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr11.cast_mut();
                  },
                  None => {
                    {
                      *ptr1.add(8+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };match trailing2 {
                  Some(e) => {
                    *ptr1.add(8+11*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    let vec16 = e;
                    let len16 = vec16.len();
                    let layout16 = _rt::alloc::Layout::from_size_align_unchecked(vec16.len() * (8+7*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
                    let result16 = if layout16.size() != 0 {
                      let ptr = _rt::alloc::alloc(layout16).cast::<u8>();
                      if ptr.is_null()
                      {
                        _rt::alloc::handle_alloc_error(layout16);
                      }
                      ptr
                    }else {
                      ::core::ptr::null_mut()
                    };
                    for (i, e) in vec16.into_iter().enumerate() {
                      let base = result16.add(i * (8+7*::core::mem::size_of::<*const u8>()));
                      {
                        let super::super::super::super::exports::ritalin::scanner::types::TokenItem{ kind:kind12, offset:offset12, len:len12, value:value12, } = e;
                        let super::super::super::super::exports::ritalin::scanner::types::SyntaxKind{ id:id13, text:text13, is_keyword:is_keyword13, is_terminal:is_terminal13, } = kind12;
                        *base.add(0).cast::<i32>() = _rt::as_i32(id13);
                        let vec14 = (text13.into_bytes()).into_boxed_slice();
                        let ptr14 = vec14.as_ptr().cast::<u8>();
                        let len14 = vec14.len();
                        ::core::mem::forget(vec14);
                        *base.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len14;
                        *base.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr14.cast_mut();
                        *base.add(3*::core::mem::size_of::<*const u8>()).cast::<u8>() = (match is_keyword13 { true => 1, false => 0 }) as u8;
                        *base.add(1+3*::core::mem::size_of::<*const u8>()).cast::<u8>() = (match is_terminal13 { true => 1, false => 0 }) as u8;
                        *base.add(4*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(offset12);
                        *base.add(4+4*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(len12);
                        match value12 {
                          Some(e) => {
                            *base.add(8+4*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                            let vec15 = (e.into_bytes()).into_boxed_slice();
                            let ptr15 = vec15.as_ptr().cast::<u8>();
                            let len15 = vec15.len();
                            ::core::mem::forget(vec15);
                            *base.add(8+6*::core::mem::size_of::<*const u8>()).cast::<usize>() = len15;
                            *base.add(8+5*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr15.cast_mut();
                          },
                          None => {
                            {
                              *base.add(8+4*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                            }
                          },
                        };}
                      }
                      *ptr1.add(8+13*::core::mem::size_of::<*const u8>()).cast::<usize>() = len16;
                      *ptr1.add(8+12*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result16;
                    },
                    None => {
                      {
                        *ptr1.add(8+11*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };},
                  None => {
                    {
                      *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };ptr1
              }
              #[doc(hidden)]
              #[allow(non_snake_case)]
              pub unsafe fn __post_return_method_scanner_shift<T: GuestScanner>(arg0: *mut u8,) {
                let l0 = i32::from(*arg0.add(0).cast::<u8>());
                match l0 {
                  0 => (),
                  _ => {
                    let l1 = i32::from(*arg0.add(::core::mem::size_of::<*const u8>()).cast::<u8>());
                    match l1 {
                      0 => (),
                      _ => {
                        let l2 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l3 = *arg0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        let base9 = l2;
                        let len9 = l3;
                        for i in 0..len9 {
                          let base = base9.add(i * (8+7*::core::mem::size_of::<*const u8>()));
                          {
                            let l4 = *base.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                            let l5 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                            _rt::cabi_dealloc(l4, l5, 1);
                            let l6 = i32::from(*base.add(8+4*::core::mem::size_of::<*const u8>()).cast::<u8>());
                            match l6 {
                              0 => (),
                              _ => {
                                let l7 = *base.add(8+5*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                let l8 = *base.add(8+6*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                _rt::cabi_dealloc(l7, l8, 1);
                              },
                            }
                          }
                        }
                        _rt::cabi_dealloc(base9, len9 * (8+7*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
                      },
                    }
                    let l10 = *arg0.add(5*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l11 = *arg0.add(6*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l10, l11, 1);
                    let l12 = i32::from(*arg0.add(8+8*::core::mem::size_of::<*const u8>()).cast::<u8>());
                    match l12 {
                      0 => (),
                      _ => {
                        let l13 = *arg0.add(8+9*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l14 = *arg0.add(8+10*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        _rt::cabi_dealloc(l13, l14, 1);
                      },
                    }
                    let l15 = i32::from(*arg0.add(8+11*::core::mem::size_of::<*const u8>()).cast::<u8>());
                    match l15 {
                      0 => (),
                      _ => {
                        let l16 = *arg0.add(8+12*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l17 = *arg0.add(8+13*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        let base23 = l16;
                        let len23 = l17;
                        for i in 0..len23 {
                          let base = base23.add(i * (8+7*::core::mem::size_of::<*const u8>()));
                          {
                            let l18 = *base.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                            let l19 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                            _rt::cabi_dealloc(l18, l19, 1);
                            let l20 = i32::from(*base.add(8+4*::core::mem::size_of::<*const u8>()).cast::<u8>());
                            match l20 {
                              0 => (),
                              _ => {
                                let l21 = *base.add(8+5*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                let l22 = *base.add(8+6*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                _rt::cabi_dealloc(l21, l22, 1);
                              },
                            }
                          }
                        }
                        _rt::cabi_dealloc(base23, len23 * (8+7*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
                      },
                    }
                  },
                }
              }
              #[doc(hidden)]
              #[allow(non_snake_case)]
              pub unsafe fn _export_method_scanner_scope_cabi<T: GuestScanner>(arg0: *mut u8,) -> *mut u8 {#[cfg(target_arch="wasm32")]
              _rt::run_ctors_once();let result0 = T::scope(unsafe { ScannerBorrow::lift(arg0 as u32 as usize) }.get());
              let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
              let super::super::super::super::exports::ritalin::scanner::types::ScannerScope{ next_index:next_index2, lookahead:lookahead2, } = result0;
              *ptr1.add(0).cast::<i32>() = _rt::as_i32(next_index2);
              match lookahead2 {
                Some(e) => {
                  *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let super::super::super::super::exports::ritalin::scanner::types::Token{ leading:leading3, main:main3, trailing:trailing3, } = e;
                  match leading3 {
                    Some(e) => {
                      *ptr1.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                      let vec8 = e;
                      let len8 = vec8.len();
                      let layout8 = _rt::alloc::Layout::from_size_align_unchecked(vec8.len() * (8+7*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
                      let result8 = if layout8.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout8).cast::<u8>();
                        if ptr.is_null()
                        {
                          _rt::alloc::handle_alloc_error(layout8);
                        }
                        ptr
                      }else {
                        ::core::ptr::null_mut()
                      };
                      for (i, e) in vec8.into_iter().enumerate() {
                        let base = result8.add(i * (8+7*::core::mem::size_of::<*const u8>()));
                        {
                          let super::super::super::super::exports::ritalin::scanner::types::TokenItem{ kind:kind4, offset:offset4, len:len4, value:value4, } = e;
                          let super::super::super::super::exports::ritalin::scanner::types::SyntaxKind{ id:id5, text:text5, is_keyword:is_keyword5, is_terminal:is_terminal5, } = kind4;
                          *base.add(0).cast::<i32>() = _rt::as_i32(id5);
                          let vec6 = (text5.into_bytes()).into_boxed_slice();
                          let ptr6 = vec6.as_ptr().cast::<u8>();
                          let len6 = vec6.len();
                          ::core::mem::forget(vec6);
                          *base.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len6;
                          *base.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr6.cast_mut();
                          *base.add(3*::core::mem::size_of::<*const u8>()).cast::<u8>() = (match is_keyword5 { true => 1, false => 0 }) as u8;
                          *base.add(1+3*::core::mem::size_of::<*const u8>()).cast::<u8>() = (match is_terminal5 { true => 1, false => 0 }) as u8;
                          *base.add(4*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(offset4);
                          *base.add(4+4*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(len4);
                          match value4 {
                            Some(e) => {
                              *base.add(8+4*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                              let vec7 = (e.into_bytes()).into_boxed_slice();
                              let ptr7 = vec7.as_ptr().cast::<u8>();
                              let len7 = vec7.len();
                              ::core::mem::forget(vec7);
                              *base.add(8+6*::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
                              *base.add(8+5*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr7.cast_mut();
                            },
                            None => {
                              {
                                *base.add(8+4*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                              }
                            },
                          };}
                        }
                        *ptr1.add(4*::core::mem::size_of::<*const u8>()).cast::<usize>() = len8;
                        *ptr1.add(3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result8;
                      },
                      None => {
                        {
                          *ptr1.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                        }
                      },
                    };let super::super::super::super::exports::ritalin::scanner::types::TokenItem{ kind:kind9, offset:offset9, len:len9, value:value9, } = main3;
                    let super::super::super::super::exports::ritalin::scanner::types::SyntaxKind{ id:id10, text:text10, is_keyword:is_keyword10, is_terminal:is_terminal10, } = kind9;
                    *ptr1.add(5*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(id10);
                    let vec11 = (text10.into_bytes()).into_boxed_slice();
                    let ptr11 = vec11.as_ptr().cast::<u8>();
                    let len11 = vec11.len();
                    ::core::mem::forget(vec11);
                    *ptr1.add(7*::core::mem::size_of::<*const u8>()).cast::<usize>() = len11;
                    *ptr1.add(6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr11.cast_mut();
                    *ptr1.add(8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (match is_keyword10 { true => 1, false => 0 }) as u8;
                    *ptr1.add(1+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (match is_terminal10 { true => 1, false => 0 }) as u8;
                    *ptr1.add(9*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(offset9);
                    *ptr1.add(4+9*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(len9);
                    match value9 {
                      Some(e) => {
                        *ptr1.add(8+9*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                        let vec12 = (e.into_bytes()).into_boxed_slice();
                        let ptr12 = vec12.as_ptr().cast::<u8>();
                        let len12 = vec12.len();
                        ::core::mem::forget(vec12);
                        *ptr1.add(8+11*::core::mem::size_of::<*const u8>()).cast::<usize>() = len12;
                        *ptr1.add(8+10*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr12.cast_mut();
                      },
                      None => {
                        {
                          *ptr1.add(8+9*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                        }
                      },
                    };match trailing3 {
                      Some(e) => {
                        *ptr1.add(8+12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                        let vec17 = e;
                        let len17 = vec17.len();
                        let layout17 = _rt::alloc::Layout::from_size_align_unchecked(vec17.len() * (8+7*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
                        let result17 = if layout17.size() != 0 {
                          let ptr = _rt::alloc::alloc(layout17).cast::<u8>();
                          if ptr.is_null()
                          {
                            _rt::alloc::handle_alloc_error(layout17);
                          }
                          ptr
                        }else {
                          ::core::ptr::null_mut()
                        };
                        for (i, e) in vec17.into_iter().enumerate() {
                          let base = result17.add(i * (8+7*::core::mem::size_of::<*const u8>()));
                          {
                            let super::super::super::super::exports::ritalin::scanner::types::TokenItem{ kind:kind13, offset:offset13, len:len13, value:value13, } = e;
                            let super::super::super::super::exports::ritalin::scanner::types::SyntaxKind{ id:id14, text:text14, is_keyword:is_keyword14, is_terminal:is_terminal14, } = kind13;
                            *base.add(0).cast::<i32>() = _rt::as_i32(id14);
                            let vec15 = (text14.into_bytes()).into_boxed_slice();
                            let ptr15 = vec15.as_ptr().cast::<u8>();
                            let len15 = vec15.len();
                            ::core::mem::forget(vec15);
                            *base.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len15;
                            *base.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr15.cast_mut();
                            *base.add(3*::core::mem::size_of::<*const u8>()).cast::<u8>() = (match is_keyword14 { true => 1, false => 0 }) as u8;
                            *base.add(1+3*::core::mem::size_of::<*const u8>()).cast::<u8>() = (match is_terminal14 { true => 1, false => 0 }) as u8;
                            *base.add(4*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(offset13);
                            *base.add(4+4*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(len13);
                            match value13 {
                              Some(e) => {
                                *base.add(8+4*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                let vec16 = (e.into_bytes()).into_boxed_slice();
                                let ptr16 = vec16.as_ptr().cast::<u8>();
                                let len16 = vec16.len();
                                ::core::mem::forget(vec16);
                                *base.add(8+6*::core::mem::size_of::<*const u8>()).cast::<usize>() = len16;
                                *base.add(8+5*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr16.cast_mut();
                              },
                              None => {
                                {
                                  *base.add(8+4*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                }
                              },
                            };}
                          }
                          *ptr1.add(8+14*::core::mem::size_of::<*const u8>()).cast::<usize>() = len17;
                          *ptr1.add(8+13*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result17;
                        },
                        None => {
                          {
                            *ptr1.add(8+12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };},
                      None => {
                        {
                          *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                        }
                      },
                    };ptr1
                  }
                  #[doc(hidden)]
                  #[allow(non_snake_case)]
                  pub unsafe fn __post_return_method_scanner_scope<T: GuestScanner>(arg0: *mut u8,) {
                    let l0 = i32::from(*arg0.add(::core::mem::size_of::<*const u8>()).cast::<u8>());
                    match l0 {
                      0 => (),
                      _ => {
                        let l1 = i32::from(*arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>());
                        match l1 {
                          0 => (),
                          _ => {
                            let l2 = *arg0.add(3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                            let l3 = *arg0.add(4*::core::mem::size_of::<*const u8>()).cast::<usize>();
                            let base9 = l2;
                            let len9 = l3;
                            for i in 0..len9 {
                              let base = base9.add(i * (8+7*::core::mem::size_of::<*const u8>()));
                              {
                                let l4 = *base.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                let l5 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                _rt::cabi_dealloc(l4, l5, 1);
                                let l6 = i32::from(*base.add(8+4*::core::mem::size_of::<*const u8>()).cast::<u8>());
                                match l6 {
                                  0 => (),
                                  _ => {
                                    let l7 = *base.add(8+5*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                    let l8 = *base.add(8+6*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                    _rt::cabi_dealloc(l7, l8, 1);
                                  },
                                }
                              }
                            }
                            _rt::cabi_dealloc(base9, len9 * (8+7*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
                          },
                        }
                        let l10 = *arg0.add(6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l11 = *arg0.add(7*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        _rt::cabi_dealloc(l10, l11, 1);
                        let l12 = i32::from(*arg0.add(8+9*::core::mem::size_of::<*const u8>()).cast::<u8>());
                        match l12 {
                          0 => (),
                          _ => {
                            let l13 = *arg0.add(8+10*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                            let l14 = *arg0.add(8+11*::core::mem::size_of::<*const u8>()).cast::<usize>();
                            _rt::cabi_dealloc(l13, l14, 1);
                          },
                        }
                        let l15 = i32::from(*arg0.add(8+12*::core::mem::size_of::<*const u8>()).cast::<u8>());
                        match l15 {
                          0 => (),
                          _ => {
                            let l16 = *arg0.add(8+13*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                            let l17 = *arg0.add(8+14*::core::mem::size_of::<*const u8>()).cast::<usize>();
                            let base23 = l16;
                            let len23 = l17;
                            for i in 0..len23 {
                              let base = base23.add(i * (8+7*::core::mem::size_of::<*const u8>()));
                              {
                                let l18 = *base.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                let l19 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                _rt::cabi_dealloc(l18, l19, 1);
                                let l20 = i32::from(*base.add(8+4*::core::mem::size_of::<*const u8>()).cast::<u8>());
                                match l20 {
                                  0 => (),
                                  _ => {
                                    let l21 = *base.add(8+5*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                    let l22 = *base.add(8+6*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                    _rt::cabi_dealloc(l21, l22, 1);
                                  },
                                }
                              }
                            }
                            _rt::cabi_dealloc(base23, len23 * (8+7*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
                          },
                        }
                      },
                    }
                  }
                  #[doc(hidden)]
                  #[allow(non_snake_case)]
                  pub unsafe fn _export_method_scanner_revert_cabi<T: GuestScanner>(arg0: *mut u8,) {#[cfg(target_arch="wasm32")]
                  _rt::run_ctors_once();let l0 = *arg0.add(0).cast::<i32>();
                  let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<i32>();
                  let l2 = i32::from(*arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>());
                  T::revert(unsafe { ScannerBorrow::lift(l0 as u32 as usize) }.get(), super::super::super::super::exports::ritalin::scanner::types::ScannerScope{
                    next_index: l1 as u32,
                    lookahead: match l2 {
                      0 => None,
                      1 => {
                        let e = {
                          let l3 = i32::from(*arg0.add(3*::core::mem::size_of::<*const u8>()).cast::<u8>());
                          let l19 = *arg0.add(6*::core::mem::size_of::<*const u8>()).cast::<i32>();
                          let l20 = *arg0.add(7*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                          let l21 = *arg0.add(8*::core::mem::size_of::<*const u8>()).cast::<usize>();
                          let len22 = l21;
                          let bytes22 = _rt::Vec::from_raw_parts(l20.cast(), len22, len22);
                          let l23 = i32::from(*arg0.add(9*::core::mem::size_of::<*const u8>()).cast::<u8>());
                          let l24 = i32::from(*arg0.add(1+9*::core::mem::size_of::<*const u8>()).cast::<u8>());
                          let l25 = *arg0.add(10*::core::mem::size_of::<*const u8>()).cast::<i32>();
                          let l26 = *arg0.add(4+10*::core::mem::size_of::<*const u8>()).cast::<i32>();
                          let l27 = i32::from(*arg0.add(8+10*::core::mem::size_of::<*const u8>()).cast::<u8>());
                          let l31 = i32::from(*arg0.add(8+13*::core::mem::size_of::<*const u8>()).cast::<u8>());

                          super::super::super::super::exports::ritalin::scanner::types::Token{
                            leading: match l3 {
                              0 => None,
                              1 => {
                                let e = {
                                  let l4 = *arg0.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                  let l5 = *arg0.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                  let base18 = l4;
                                  let len18 = l5;
                                  let mut result18 = _rt::Vec::with_capacity(len18);
                                  for i in 0..len18 {
                                    let base = base18.add(i * (8+7*::core::mem::size_of::<*const u8>()));
                                    let e18 = {
                                      let l6 = *base.add(0).cast::<i32>();
                                      let l7 = *base.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                      let l8 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                      let len9 = l8;
                                      let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
                                      let l10 = i32::from(*base.add(3*::core::mem::size_of::<*const u8>()).cast::<u8>());
                                      let l11 = i32::from(*base.add(1+3*::core::mem::size_of::<*const u8>()).cast::<u8>());
                                      let l12 = *base.add(4*::core::mem::size_of::<*const u8>()).cast::<i32>();
                                      let l13 = *base.add(4+4*::core::mem::size_of::<*const u8>()).cast::<i32>();
                                      let l14 = i32::from(*base.add(8+4*::core::mem::size_of::<*const u8>()).cast::<u8>());

                                      super::super::super::super::exports::ritalin::scanner::types::TokenItem{
                                        kind: super::super::super::super::exports::ritalin::scanner::types::SyntaxKind{
                                          id: l6 as u32,
                                          text: _rt::string_lift(bytes9),
                                          is_keyword: _rt::bool_lift(l10 as u8),
                                          is_terminal: _rt::bool_lift(l11 as u8),
                                        },
                                        offset: l12 as u32,
                                        len: l13 as u32,
                                        value: match l14 {
                                          0 => None,
                                          1 => {
                                            let e = {
                                              let l15 = *base.add(8+5*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                              let l16 = *base.add(8+6*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                              let len17 = l16;
                                              let bytes17 = _rt::Vec::from_raw_parts(l15.cast(), len17, len17);

                                              _rt::string_lift(bytes17)
                                            };
                                            Some(e)
                                          }
                                          _ => _rt::invalid_enum_discriminant(),
                                        },
                                      }
                                    };
                                    result18.push(e18);
                                  }
                                  _rt::cabi_dealloc(base18, len18 * (8+7*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());

                                  result18
                                };
                                Some(e)
                              }
                              _ => _rt::invalid_enum_discriminant(),
                            },
                            main: super::super::super::super::exports::ritalin::scanner::types::TokenItem{
                              kind: super::super::super::super::exports::ritalin::scanner::types::SyntaxKind{
                                id: l19 as u32,
                                text: _rt::string_lift(bytes22),
                                is_keyword: _rt::bool_lift(l23 as u8),
                                is_terminal: _rt::bool_lift(l24 as u8),
                              },
                              offset: l25 as u32,
                              len: l26 as u32,
                              value: match l27 {
                                0 => None,
                                1 => {
                                  let e = {
                                    let l28 = *arg0.add(8+11*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                    let l29 = *arg0.add(8+12*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                    let len30 = l29;
                                    let bytes30 = _rt::Vec::from_raw_parts(l28.cast(), len30, len30);

                                    _rt::string_lift(bytes30)
                                  };
                                  Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                              },
                            },
                            trailing: match l31 {
                              0 => None,
                              1 => {
                                let e = {
                                  let l32 = *arg0.add(8+14*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                  let l33 = *arg0.add(8+15*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                  let base46 = l32;
                                  let len46 = l33;
                                  let mut result46 = _rt::Vec::with_capacity(len46);
                                  for i in 0..len46 {
                                    let base = base46.add(i * (8+7*::core::mem::size_of::<*const u8>()));
                                    let e46 = {
                                      let l34 = *base.add(0).cast::<i32>();
                                      let l35 = *base.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                      let l36 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                      let len37 = l36;
                                      let bytes37 = _rt::Vec::from_raw_parts(l35.cast(), len37, len37);
                                      let l38 = i32::from(*base.add(3*::core::mem::size_of::<*const u8>()).cast::<u8>());
                                      let l39 = i32::from(*base.add(1+3*::core::mem::size_of::<*const u8>()).cast::<u8>());
                                      let l40 = *base.add(4*::core::mem::size_of::<*const u8>()).cast::<i32>();
                                      let l41 = *base.add(4+4*::core::mem::size_of::<*const u8>()).cast::<i32>();
                                      let l42 = i32::from(*base.add(8+4*::core::mem::size_of::<*const u8>()).cast::<u8>());

                                      super::super::super::super::exports::ritalin::scanner::types::TokenItem{
                                        kind: super::super::super::super::exports::ritalin::scanner::types::SyntaxKind{
                                          id: l34 as u32,
                                          text: _rt::string_lift(bytes37),
                                          is_keyword: _rt::bool_lift(l38 as u8),
                                          is_terminal: _rt::bool_lift(l39 as u8),
                                        },
                                        offset: l40 as u32,
                                        len: l41 as u32,
                                        value: match l42 {
                                          0 => None,
                                          1 => {
                                            let e = {
                                              let l43 = *base.add(8+5*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                              let l44 = *base.add(8+6*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                              let len45 = l44;
                                              let bytes45 = _rt::Vec::from_raw_parts(l43.cast(), len45, len45);

                                              _rt::string_lift(bytes45)
                                            };
                                            Some(e)
                                          }
                                          _ => _rt::invalid_enum_discriminant(),
                                        },
                                      }
                                    };
                                    result46.push(e46);
                                  }
                                  _rt::cabi_dealloc(base46, len46 * (8+7*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());

                                  result46
                                };
                                Some(e)
                              }
                              _ => _rt::invalid_enum_discriminant(),
                            },
                          }
                        };
                        Some(e)
                      }
                      _ => _rt::invalid_enum_discriminant(),
                    },
                  });
                  _rt::cabi_dealloc(arg0, 8+16*::core::mem::size_of::<*const u8>(), ::core::mem::size_of::<*const u8>());
                }
                pub trait Guest {
                  type Scanner: GuestScanner;
                }
                pub trait GuestScanner: 'static {

                  #[doc(hidden)]
                  unsafe fn _resource_new(val: *mut u8) -> u32
                  where Self: Sized
                  {
                    #[cfg(not(target_arch = "wasm32"))]
                    {
                      let _ = val;
                      unreachable!();
                    }

                    #[cfg(target_arch = "wasm32")]
                    {
                      #[link(wasm_import_module = "[export]ritalin:scanner/scanners@0.0.1")]
                      unsafe extern "C" {
                        #[link_name = "[resource-new]scanner"]
                        fn new(_: *mut u8) -> u32;
                      }
                      unsafe { new(val) }
                    }
                  }

                  #[doc(hidden)]
                  fn _resource_rep(handle: u32) -> *mut u8
                  where Self: Sized
                  {
                    #[cfg(not(target_arch = "wasm32"))]
                    {
                      let _ = handle;
                      unreachable!();
                    }

                    #[cfg(target_arch = "wasm32")]
                    {
                      #[link(wasm_import_module = "[export]ritalin:scanner/scanners@0.0.1")]
                      unsafe extern "C" {
                        #[link_name = "[resource-rep]scanner"]
                        fn rep(_: u32) -> *mut u8;
                      }
                      unsafe {
                        rep(handle)
                      }
                    }
                  }

                  
                  /// Create new scanner instance.
                  /// If you want to skip index for scouece string, pass `index-from` to more `0`.
                  fn create(source: _rt::String,index_from: u32,) -> Scanner;
                  fn lookahead(&self,) -> Option<Token>;
                  fn shift(&self,) -> Option<Token>;
                  fn scope(&self,) -> ScannerScope;
                  fn revert(&self,scope: ScannerScope,) -> ();
                }
                #[doc(hidden)]

                macro_rules! __export_ritalin_scanner_scanners_0_0_1_cabi{
                  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

                    #[unsafe(export_name = "ritalin:scanner/scanners@0.0.1#[static]scanner.create")]
                    unsafe extern "C" fn export_static_scanner_create(arg0: *mut u8,arg1: usize,arg2: i32,) -> i32 {
                      unsafe { $($path_to_types)*::_export_static_scanner_create_cabi::<<$ty as $($path_to_types)*::Guest>::Scanner>(arg0, arg1, arg2) }
                    }
                    #[unsafe(export_name = "ritalin:scanner/scanners@0.0.1#[method]scanner.lookahead")]
                    unsafe extern "C" fn export_method_scanner_lookahead(arg0: *mut u8,) -> *mut u8 {
                      unsafe { $($path_to_types)*::_export_method_scanner_lookahead_cabi::<<$ty as $($path_to_types)*::Guest>::Scanner>(arg0) }
                    }
                    #[unsafe(export_name = "cabi_post_ritalin:scanner/scanners@0.0.1#[method]scanner.lookahead")]
                    unsafe extern "C" fn _post_return_method_scanner_lookahead(arg0: *mut u8,) {
                      unsafe { $($path_to_types)*::__post_return_method_scanner_lookahead::<<$ty as $($path_to_types)*::Guest>::Scanner>(arg0) }
                    }
                    #[unsafe(export_name = "ritalin:scanner/scanners@0.0.1#[method]scanner.shift")]
                    unsafe extern "C" fn export_method_scanner_shift(arg0: *mut u8,) -> *mut u8 {
                      unsafe { $($path_to_types)*::_export_method_scanner_shift_cabi::<<$ty as $($path_to_types)*::Guest>::Scanner>(arg0) }
                    }
                    #[unsafe(export_name = "cabi_post_ritalin:scanner/scanners@0.0.1#[method]scanner.shift")]
                    unsafe extern "C" fn _post_return_method_scanner_shift(arg0: *mut u8,) {
                      unsafe { $($path_to_types)*::__post_return_method_scanner_shift::<<$ty as $($path_to_types)*::Guest>::Scanner>(arg0) }
                    }
                    #[unsafe(export_name = "ritalin:scanner/scanners@0.0.1#[method]scanner.scope")]
                    unsafe extern "C" fn export_method_scanner_scope(arg0: *mut u8,) -> *mut u8 {
                      unsafe { $($path_to_types)*::_export_method_scanner_scope_cabi::<<$ty as $($path_to_types)*::Guest>::Scanner>(arg0) }
                    }
                    #[unsafe(export_name = "cabi_post_ritalin:scanner/scanners@0.0.1#[method]scanner.scope")]
                    unsafe extern "C" fn _post_return_method_scanner_scope(arg0: *mut u8,) {
                      unsafe { $($path_to_types)*::__post_return_method_scanner_scope::<<$ty as $($path_to_types)*::Guest>::Scanner>(arg0) }
                    }
                    #[unsafe(export_name = "ritalin:scanner/scanners@0.0.1#[method]scanner.revert")]
                    unsafe extern "C" fn export_method_scanner_revert(arg0: *mut u8,) {
                      unsafe { $($path_to_types)*::_export_method_scanner_revert_cabi::<<$ty as $($path_to_types)*::Guest>::Scanner>(arg0) }
                    }

                    const _: () = {
                      #[doc(hidden)]
                      #[unsafe(export_name = "ritalin:scanner/scanners@0.0.1#[dtor]scanner")]
                      #[allow(non_snake_case)]
                      unsafe extern "C" fn dtor(rep: *mut u8) {
                        unsafe {
                          $($path_to_types)*::Scanner::dtor::<
                          <$ty as $($path_to_types)*::Guest>::Scanner
                          >(rep)
                        }
                      }
                    };
                    
                  };);
                }
                #[doc(hidden)]
                pub(crate) use __export_ritalin_scanner_scanners_0_0_1_cabi;

                #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                struct _RetArea([::core::mem::MaybeUninit::<u8>; 8+15*::core::mem::size_of::<*const u8>()]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 8+15*::core::mem::size_of::<*const u8>()]);

              }

            }
          }
        }
        mod _rt {
          #![allow(dead_code, clippy::all)]
          pub use alloc_crate::string::String;
          pub use alloc_crate::vec::Vec;


          use core::fmt;
          use core::marker;
          use core::sync::atomic::{AtomicU32, Ordering::Relaxed};

          /// A type which represents a component model resource, either imported or
          /// exported into this component.
          ///
          /// This is a low-level wrapper which handles the lifetime of the resource
          /// (namely this has a destructor). The `T` provided defines the component model
          /// intrinsics that this wrapper uses.
          ///
          /// One of the chief purposes of this type is to provide `Deref` implementations
          /// to access the underlying data when it is owned.
          ///
          /// This type is primarily used in generated code for exported and imported
          /// resources.
          #[repr(transparent)]
          pub struct Resource<T: WasmResource> {
            // NB: This would ideally be `u32` but it is not. The fact that this has
            // interior mutability is not exposed in the API of this type except for the
            // `take_handle` method which is supposed to in theory be private.
            //
            // This represents, almost all the time, a valid handle value. When it's
            // invalid it's stored as `u32::MAX`.
            handle: AtomicU32,
            _marker: marker::PhantomData<T>,
          }

          /// A trait which all wasm resources implement, namely providing the ability to
          /// drop a resource.
          ///
          /// This generally is implemented by generated code, not user-facing code.
          #[allow(clippy::missing_safety_doc)]
          pub unsafe trait WasmResource {
            /// Invokes the `[resource-drop]...` intrinsic.
            unsafe fn drop(handle: u32);
          }

          impl<T: WasmResource> Resource<T> {
            #[doc(hidden)]
            pub unsafe fn from_handle(handle: u32) -> Self {
              debug_assert!(handle != u32::MAX);
              Self {
                handle: AtomicU32::new(handle),
                _marker: marker::PhantomData,
              }
            }

            /// Takes ownership of the handle owned by `resource`.
            ///
            /// Note that this ideally would be `into_handle` taking `Resource<T>` by
            /// ownership. The code generator does not enable that in all situations,
            /// unfortunately, so this is provided instead.
            ///
            /// Also note that `take_handle` is in theory only ever called on values
            /// owned by a generated function. For example a generated function might
            /// take `Resource<T>` as an argument but then call `take_handle` on a
            /// reference to that argument. In that sense the dynamic nature of
            /// `take_handle` should only be exposed internally to generated code, not
            /// to user code.
            #[doc(hidden)]
            pub fn take_handle(resource: &Resource<T>) -> u32 {
              resource.handle.swap(u32::MAX, Relaxed)
            }

            #[doc(hidden)]
            pub fn handle(resource: &Resource<T>) -> u32 {
              resource.handle.load(Relaxed)
            }
          }

          impl<T: WasmResource> fmt::Debug for Resource<T> {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("Resource")
              .field("handle", &self.handle)
              .finish()
            }
          }

          impl<T: WasmResource> Drop for Resource<T> {
            fn drop(&mut self) {
              unsafe {
                match self.handle.load(Relaxed) {
                  // If this handle was "taken" then don't do anything in the
                  // destructor.
                  u32::MAX => {}

                  // ... but otherwise do actually destroy it with the imported
                  // component model intrinsic as defined through `T`.
                  other => T::drop(other),
                }
              }
            }
          }
          pub use alloc_crate::boxed::Box;

          #[cfg(target_arch = "wasm32")]
          pub fn run_ctors_once() {
            wit_bindgen::rt::run_ctors_once();
          }
          pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
            if cfg!(debug_assertions) {
              String::from_utf8(bytes).unwrap()
            } else {
              String::from_utf8_unchecked(bytes)
            }
          }
          
          pub fn as_i32<T: AsI32>(t: T) -> i32 {
            t.as_i32()
          }

          pub trait AsI32 {
            fn as_i32(self) -> i32;
          }

          impl<'a, T: Copy + AsI32> AsI32 for &'a T {
            fn as_i32(self) -> i32 {
              (*self).as_i32()
            }
          }
          
          impl AsI32 for i32 {
            #[inline]
            fn as_i32(self) -> i32 {
              self as i32
            }
          }
          
          impl AsI32 for u32 {
            #[inline]
            fn as_i32(self) -> i32 {
              self as i32
            }
          }
          
          impl AsI32 for i16 {
            #[inline]
            fn as_i32(self) -> i32 {
              self as i32
            }
          }
          
          impl AsI32 for u16 {
            #[inline]
            fn as_i32(self) -> i32 {
              self as i32
            }
          }
          
          impl AsI32 for i8 {
            #[inline]
            fn as_i32(self) -> i32 {
              self as i32
            }
          }
          
          impl AsI32 for u8 {
            #[inline]
            fn as_i32(self) -> i32 {
              self as i32
            }
          }
          
          impl AsI32 for char {
            #[inline]
            fn as_i32(self) -> i32 {
              self as i32
            }
          }
          
          impl AsI32 for usize {
            #[inline]
            fn as_i32(self) -> i32 {
              self as i32
            }
          }
          pub use alloc_crate::alloc;
          pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
            if size == 0 {
              return;
            }
            let layout = alloc::Layout::from_size_align_unchecked(size, align);
            alloc::dealloc(ptr, layout);
          }
          pub unsafe fn bool_lift(val: u8) -> bool {
            if cfg!(debug_assertions) {
              match val {
                0 => false,
                1 => true,
                _ => panic!("invalid bool discriminant"),
              }
            } else {
              val != 0
            }
          }
          pub unsafe fn invalid_enum_discriminant<T>() -> T {
            if cfg!(debug_assertions) {
              panic!("invalid enum discriminant")
            } else {
              unsafe { core::hint::unreachable_unchecked() }
            }
          }
          extern crate alloc as alloc_crate;
        }

        /// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
        /// the root implementation of all generated traits.
        ///
        /// For more information see the documentation of `wit_bindgen::generate!`.
        ///
        /// ```rust
        /// # macro_rules! export{ ($($t:tt)*) => (); }
        /// # trait Guest {}
        /// struct MyType;
        ///
        /// impl Guest for MyType {
        ///     // ...
        /// }
        ///
        /// export!(MyType);
        /// ```
        #[allow(unused_macros)]
        #[doc(hidden)]

        macro_rules! __export_scanner_world_impl {
          ($ty:ident) => (crate::bindings::scanner_world::export!($ty with_types_in crate::bindings::scanner_world););
          ($ty:ident with_types_in $($path_to_types_root:tt)*) => (
          $($path_to_types_root)*::exports::ritalin::scanner::types::__export_ritalin_scanner_types_0_0_1_cabi!($ty with_types_in $($path_to_types_root)*::exports::ritalin::scanner::types);
          $($path_to_types_root)*::exports::ritalin::scanner::scanners::__export_ritalin_scanner_scanners_0_0_1_cabi!($ty with_types_in $($path_to_types_root)*::exports::ritalin::scanner::scanners);
          )
        }
        #[doc(inline)]
        pub(crate) use __export_scanner_world_impl as export;

        #[cfg(target_arch = "wasm32")]
        #[unsafe(link_section = "component-type:wit-bindgen:0.41.0:ritalin:scanner@0.0.1:scanner-world:encoded world")]
        #[doc(hidden)]
        #[allow(clippy::octal_escapes)]
        pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 737] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xdd\x04\x01A\x02\x01\
A\x06\x01B\x0c\x01r\x04\x02idy\x04texts\x0ais-keyword\x7f\x0bis-terminal\x7f\x04\
\0\x0bsyntax-kind\x03\0\0\x01ks\x01r\x04\x04kind\x01\x06offsety\x03leny\x05value\
\x02\x04\0\x0atoken-item\x03\0\x03\x01p\x04\x01k\x05\x01r\x03\x07leading\x06\x04\
main\x04\x08trailing\x06\x04\0\x05token\x03\0\x07\x01k\x08\x01r\x02\x0anext-inde\
xy\x09lookahead\x09\x04\0\x0dscanner-scope\x03\0\x0a\x04\0\x1britalin:scanner/ty\
pes@0.0.1\x05\0\x02\x03\0\0\x05token\x02\x03\0\0\x0dscanner-scope\x01B\x11\x02\x03\
\x02\x01\x01\x04\0\x05token\x03\0\0\x02\x03\x02\x01\x02\x04\0\x0dscanner-scope\x03\
\0\x02\x04\0\x07scanner\x03\x01\x01i\x04\x01@\x02\x06sources\x0aindex-fromy\0\x05\
\x04\0\x16[static]scanner.create\x01\x06\x01h\x04\x01k\x01\x01@\x01\x04self\x07\0\
\x08\x04\0\x19[method]scanner.lookahead\x01\x09\x04\0\x15[method]scanner.shift\x01\
\x09\x01@\x01\x04self\x07\0\x03\x04\0\x15[method]scanner.scope\x01\x0a\x01@\x02\x04\
self\x07\x05scope\x03\x01\0\x04\0\x16[method]scanner.revert\x01\x0b\x04\0\x1erit\
alin:scanner/scanners@0.0.1\x05\x03\x04\0#ritalin:scanner/scanner-world@0.0.1\x04\
\0\x0b\x13\x01\0\x0dscanner-world\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\
\x0dwit-component\x070.227.1\x10wit-bindgen-rust\x060.41.0";

        #[inline(never)]
        #[doc(hidden)]
        pub fn __link_custom_section_describing_imports() {
          wit_bindgen::rt::maybe_link_cabi_realloc();
        }
        
